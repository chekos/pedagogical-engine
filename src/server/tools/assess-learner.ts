import { tool } from "@anthropic-ai/claude-agent-sdk";
import { z } from "zod";
import fs from "fs/promises";
import path from "path";
import { DATA_DIR, toolResponse } from "./shared.js";

/**
 * Run dependency inference: given demonstrated skills, infer prerequisites
 * with confidence decay.
 */
async function runDependencyInference(
  domain: string,
  demonstratedSkills: Array<{ skillId: string; confidence: number }>
): Promise<Array<{ skillId: string; confidence: number }>> {
  const domainDir = path.join(DATA_DIR, "domains", domain);
  const depsRaw = await fs.readFile(
    path.join(domainDir, "dependencies.json"),
    "utf-8"
  );
  const { edges } = JSON.parse(depsRaw);

  const bestConfidence = new Map<string, number>();

  // Set demonstrated skills
  for (const { skillId, confidence } of demonstratedSkills) {
    bestConfidence.set(skillId, confidence);
  }

  // For each demonstrated skill, infer prerequisites
  for (const { skillId, confidence: baseConf } of demonstratedSkills) {
    const queue: Array<{ id: string; confidence: number }> = [];

    const directPrereqs = edges.filter(
      (e: { target: string }) => e.target === skillId
    );
    for (const edge of directPrereqs) {
      const conf =
        Math.round(baseConf * edge.confidence * 100) / 100;
      queue.push({ id: edge.source, confidence: conf });
    }

    while (queue.length > 0) {
      const current = queue.shift()!;
      const existing = bestConfidence.get(current.id) ?? 0;

      if (current.confidence > existing) {
        bestConfidence.set(current.id, current.confidence);
      }

      // Continue traversal only if this is a better path
      if (current.confidence > existing) {
        const prereqEdges = edges.filter(
          (e: { target: string }) => e.target === current.id
        );
        for (const edge of prereqEdges) {
          const newConf =
            Math.round(current.confidence * edge.confidence * 100) / 100;
          const prevBest = bestConfidence.get(edge.source) ?? 0;
          if (newConf > prevBest) {
            queue.push({ id: edge.source, confidence: newConf });
          }
        }
      }
    }
  }

  // Return only inferred skills (not the demonstrated ones)
  const demonstratedIds = new Set(demonstratedSkills.map((s) => s.skillId));
  const inferred: Array<{ skillId: string; confidence: number }> = [];
  for (const [skillId, confidence] of bestConfidence.entries()) {
    if (!demonstratedIds.has(skillId)) {
      inferred.push({ skillId, confidence });
    }
  }

  return inferred.sort((a, b) => b.confidence - a.confidence);
}

export const assessLearnerTool = tool(
  "assess_learner",
  "Update a learner's profile with assessment results and run dependency inference to update inferred skills. Optionally apply integrity modifiers to adjust confidence based on response pattern analysis.",
  {
    learnerId: z.string().describe("Learner's file ID (without .md)"),
    domain: z.string().describe("Skill domain"),
    assessedSkills: z
      .array(
        z.object({
          skillId: z.string(),
          confidence: z.number().describe("0.0 to 1.0"),
          bloomLevel: z
            .string()
            .describe(
              "Bloom's level demonstrated: knowledge, comprehension, application, analysis, synthesis, evaluation"
            ),
          notes: z.string().optional().describe("Assessment notes"),
        })
      )
      .describe("Skills that were directly assessed"),
    integrityModifier: z
      .number()
      .min(0)
      .max(1)
      .optional()
      .describe(
        "Overall integrity modifier (0.0-1.0) from analyze_assessment_integrity. Applied to all confidence values. Omit to skip integrity adjustment."
      ),
    integrityNotes: z
      .string()
      .optional()
      .describe(
        "Integrity notes markdown to append to the learner profile. Generated by analyze_assessment_integrity."
      ),
  },
  async ({ learnerId, domain, assessedSkills, integrityModifier, integrityNotes }) => {
    const learnerPath = path.join(DATA_DIR, "learners", `${learnerId}.md`);

    let content: string;
    try {
      content = await fs.readFile(learnerPath, "utf-8");
    } catch {
      return toolResponse({
        error: `Learner profile '${learnerId}' not found`,
      }, true);
    }

    // Apply integrity modifier to confidence values if provided
    const adjustedSkills = assessedSkills.map((s) => {
      if (integrityModifier !== undefined && integrityModifier < 1.0) {
        return {
          ...s,
          confidence: Math.round(s.confidence * integrityModifier * 100) / 100,
          originalConfidence: s.confidence,
        };
      }
      return { ...s, originalConfidence: s.confidence };
    });

    // Run dependency inference with (possibly adjusted) confidence values
    const inferred = await runDependencyInference(
      domain,
      adjustedSkills.map((s) => ({
        skillId: s.skillId,
        confidence: s.confidence,
      }))
    );

    // Build updated skills sections
    const assessedSection = adjustedSkills
      .map((s) => {
        let line = `- ${s.skillId}: ${s.confidence} confidence — demonstrated at ${s.bloomLevel} level`;
        if (integrityModifier !== undefined && integrityModifier < 1.0) {
          line += ` (raw: ${s.originalConfidence}, integrity-adjusted)`;
        }
        if (s.notes) line += ` (${s.notes})`;
        return line;
      })
      .join("\n");

    const inferredSection =
      inferred.length > 0
        ? inferred
            .map((s) => `- ${s.skillId}: ${s.confidence} confidence (inferred)`)
            .join("\n")
        : "_No skills inferred._";

    const now = new Date().toISOString();

    // Update the profile content
    // Replace the Assessed Skills section
    if (content.includes("## Assessed Skills")) {
      const before = content.split("## Assessed Skills")[0];
      const afterAssessed = content.split("## Assessed Skills")[1];
      const restAfterAssessed = afterAssessed.includes("## Inferred Skills")
        ? "## Inferred Skills" +
          afterAssessed.split("## Inferred Skills")[1]
        : afterAssessed.split("##").slice(1).map((s) => "##" + s).join("");

      // Replace Inferred Skills section too
      let rest: string;
      if (restAfterAssessed.includes("## Inferred Skills")) {
        const beforeInferred = "";
        const afterInferred = restAfterAssessed.split("## Inferred Skills")[1];
        const restAfterInferred = afterInferred.includes("## Notes")
          ? "## Notes" + afterInferred.split("## Notes")[1]
          : "";

        rest = `## Inferred Skills\n\n${inferredSection}\n\n${restAfterInferred}`;
      } else {
        rest = restAfterAssessed;
      }

      content = `${before}## Assessed Skills\n\n${assessedSection}\n\n${rest}`;
    }

    // Update last assessed date
    content = content.replace(
      /\| \*\*Last assessed\*\* \| .+ \|/,
      `| **Last assessed** | ${now} |`
    );

    // Append or replace integrity notes if provided
    if (integrityNotes) {
      if (content.includes("## Assessment Integrity Notes")) {
        // Replace existing integrity section
        const beforeIntegrity = content.split("## Assessment Integrity Notes")[0];
        const afterIntegrity = content.split("## Assessment Integrity Notes")[1];
        // Find the next section after integrity notes
        const nextSection = afterIntegrity.split(/\n## (?!Assessment Integrity)/)[1];
        const rest = nextSection ? "\n## " + nextSection : "";
        content = `${beforeIntegrity}${integrityNotes}${rest}`;
      } else if (content.includes("## Notes")) {
        // Insert before Notes section
        content = content.replace("## Notes", `${integrityNotes}\n## Notes`);
      } else {
        // Append at end
        content = content.trimEnd() + "\n\n" + integrityNotes + "\n";
      }
    }

    await fs.writeFile(learnerPath, content, "utf-8");

    // Ensure the learner is listed in their group file
    const groupMatch = content.match(/\| \*\*Group\*\* \| (.+?) \|/);
    if (groupMatch) {
      const groupSlug = groupMatch[1].trim();
      const groupPath = path.join(DATA_DIR, "groups", `${groupSlug}.md`);
      try {
        let groupContent = await fs.readFile(groupPath, "utf-8");
        // Check if learner is already listed as a member
        if (!groupContent.includes(`(\`${learnerId}\`)`)) {
          // Extract learner name from profile
          const nameMatch = content.match(/\| \*\*Name\*\* \| (.+?) \|/);
          const learnerName = nameMatch?.[1]?.trim() ?? learnerId;
          // Add to members list
          if (groupContent.includes("_No members yet._")) {
            groupContent = groupContent.replace("_No members yet._", `- ${learnerName} (\`${learnerId}\`)`);
          } else {
            // Append after the last member line in the Members section
            const membersIdx = groupContent.indexOf("## Members");
            if (membersIdx !== -1) {
              const afterMembers = groupContent.slice(membersIdx);
              const nextSection = afterMembers.indexOf("\n## ", 4);
              const insertPos = nextSection !== -1
                ? membersIdx + nextSection
                : groupContent.length;
              groupContent = groupContent.slice(0, insertPos).trimEnd() +
                `\n- ${learnerName} (\`${learnerId}\`)\n` +
                groupContent.slice(insertPos);
            }
          }
          // Update member count
          const countMatch = groupContent.match(/\| \*\*Member count\*\* \| (\d+) \|/);
          if (countMatch) {
            const newCount = parseInt(countMatch[1]) + 1;
            groupContent = groupContent.replace(
              /\| \*\*Member count\*\* \| \d+ \|/,
              `| **Member count** | ${newCount} |`
            );
          }
          await fs.writeFile(groupPath, groupContent, "utf-8");
        }
      } catch {
        // Group file doesn't exist or can't be read — skip
      }
    }

    return toolResponse({
      learnerId,
      domain,
      updated: true,
      assessedSkills: adjustedSkills.map((s) => ({
        skillId: s.skillId,
        confidence: s.confidence,
        bloomLevel: s.bloomLevel,
        ...(integrityModifier !== undefined && integrityModifier < 1.0
          ? { originalConfidence: s.originalConfidence, integrityAdjusted: true }
          : {}),
      })),
      inferredSkills: inferred,
      totalAssessed: adjustedSkills.length,
      totalInferred: inferred.length,
      profilePath: learnerPath,
      lastAssessed: now,
      ...(integrityModifier !== undefined
        ? { integrityModifier, integrityApplied: integrityModifier < 1.0 }
        : {}),
    });
  }
);
